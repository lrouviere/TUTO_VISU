[
["index.html", "Tutoriel : visualisation avec R Présentation", " Tutoriel : visualisation avec R Laurent Rouvière 2020-06-01 Présentation Ce tutoriel présente quelques outils R pour la visualisation de données. Il nécessite des connaissance de base en R et en programmation et se structure en 3 parties : Visualisation avec ggplot2 : présentation du package ggplot2 pour faire des représentations graphiques avec R ; Introduction à la cartographie : construction de cartes avec les packages ggmap, sf et leaflet ; Visualisation interactive: présentation de packages qui permettent de faire facilement des graphes interactifs, des tableaux de bord ou des applications web (shiny). On pourra trouver des transparents associés à ce tutoriel ainsi que les données utilisés à l’adresse suivante https://lrouviere.github.io/VISU/. "],
["ggplot2.html", "Chapitre 1 Visualisation avec ggplot2 1.1 Fonctions graphiques conventionnelles 1.2 La grammaire ggplot2 1.3 Compléments 1.4 Quelques exercices supplémentaires", " Chapitre 1 Visualisation avec ggplot2 Il est souvent nécessaire d’utiliser des techniques de visualisation à toutes les étapes d’une étude statistique. Un des avantages de R est qu’il est relativement simple de mettre en oeuvre tout les types de graphes généralement utilisés. Dans cette fiche, nous présentons tout d’abord les fonctions classiques qui permettent de tracer des figures. Nous proposons ensuite une introduction aux graphes ggplot qui sont de plus en plus utilisés pour faire de la visualisation. 1.1 Fonctions graphiques conventionnelles Pour commencer il est intéressant d’examiner quelques exemples de représentations graphiques construits avec R. On peut les obtenir à l’aide de la fonction demo. &gt; demo(graphics) 1.1.1 La fonction plot C’est une fonction générique que l’on peut utiliser pour représenter différents types de données. L’utilisation standard consiste à visualiser une variable y en fonction d’une variable x. On peut par exemple obtenir le graphe de la fonction \\(x\\mapsto \\sin(2\\pi x)\\) sur \\([0,1]\\), à l’aide de &gt; x &lt;- seq(-2*pi,2*pi,by=0.05) &gt; y &lt;- sin(x) &gt; plot(x,y) #points (par défaut) &gt; plot(x,y,type=&quot;l&quot;) #représentation sous forme de ligne Nous proposons des exemples de représentations de variables quantitatives et qualitatives à l’aide du jeu de données ozone.txt que l’on importe avec &gt; ozone &lt;- read.table(&quot;ozone.txt&quot;) &gt; summary(ozone) ## maxO3 T9 T12 T15 ## Min. : 42.00 Min. :11.30 Min. :14.00 Min. :14.90 ## 1st Qu.: 70.75 1st Qu.:16.20 1st Qu.:18.60 1st Qu.:19.27 ## Median : 81.50 Median :17.80 Median :20.55 Median :22.05 ## Mean : 90.30 Mean :18.36 Mean :21.53 Mean :22.63 ## 3rd Qu.:106.00 3rd Qu.:19.93 3rd Qu.:23.55 3rd Qu.:25.40 ## Max. :166.00 Max. :27.00 Max. :33.50 Max. :35.50 ## Ne9 Ne12 Ne15 Vx9 ## Min. :0.000 Min. :0.000 Min. :0.00 Min. :-7.8785 ## 1st Qu.:3.000 1st Qu.:4.000 1st Qu.:3.00 1st Qu.:-3.2765 ## Median :6.000 Median :5.000 Median :5.00 Median :-0.8660 ## Mean :4.929 Mean :5.018 Mean :4.83 Mean :-1.2143 ## 3rd Qu.:7.000 3rd Qu.:7.000 3rd Qu.:7.00 3rd Qu.: 0.6946 ## Max. :8.000 Max. :8.000 Max. :8.00 Max. : 5.1962 ## Vx12 Vx15 maxO3v vent pluie ## Min. :-7.878 Min. :-9.000 Min. : 42.00 Est :10 Pluie:43 ## 1st Qu.:-3.565 1st Qu.:-3.939 1st Qu.: 71.00 Nord :31 Sec :69 ## Median :-1.879 Median :-1.550 Median : 82.50 Ouest:50 ## Mean :-1.611 Mean :-1.691 Mean : 90.57 Sud :21 ## 3rd Qu.: 0.000 3rd Qu.: 0.000 3rd Qu.:106.00 ## Max. : 6.578 Max. : 5.000 Max. :166.00 On visualise tout d’abord 2 variables quantitatives à l’aide d’un nuage de points : la concentration en ozone maximale maxO3 en fonction de la température à 12h T12. &gt; plot(ozone[,&quot;T12&quot;],ozone[,&quot;maxO3&quot;]) Comme les deux variables appartiennent au même jeu de données, on peut obtenir la même représentation à l’aide d’une sytaxe plus claire qui ajoutent automatiquement les noms des variables sur les axes : &gt; plot(maxO3~T12,data=ozone) Une autre façon de faire (moins naturelle) : &gt; plot(ozone[,&quot;T12&quot;],ozone[,&quot;maxO3&quot;],xlab=&quot;T12&quot;,ylab=&quot;maxO3&quot;) Il existe des fonctions spécifiques pour chaque type de graphs, par exemple histogram, barplot et boxplot : &gt; hist(ozone$maxO3,main=&quot;Histogram&quot;) &gt; barplot(table(ozone$vent)/nrow(ozone),col=&quot;blue&quot;) &gt; boxplot(maxO3~vent,data=ozone) 1.1.2 Graphes interactifs avec rAmCharts On peut utiliser ce package pour obtenir des graphes dynamiques. L’utilisation est relativement simple, il suffit d’ajouter le prefixe am devant le nom de la fonction : &gt; library(rAmCharts) &gt; amHist(ozone$maxO3) &gt; amPlot(ozone,col=c(&quot;T9&quot;,&quot;T12&quot;)) &gt; amBoxplot(maxO3~vent,data=ozone) Exercice 1.1 (Premier graphe) Tracer la fonction sinus entre \\(0\\) et \\(2\\pi\\). A l’aide de la fonction title ajouter le titre Représentation de la fonction sinus. &gt; x &lt;- seq(0,2*pi,length=1000) &gt; plot(x,sin(x),type=&quot;l&quot;) &gt; title(&quot;Représentation de la fonction sinus&quot;) Exercice 1.2 (Tracé de densités) Tracer la densité de la loi normale centrée réduite entre \\(-4\\) et 4 (utiliser dnorm). Ajouter une ligne verticale (en tirets) qui passe par \\(x=0\\) (utiliser abline avec lty=2). Sur le même graphe, ajouter les densités de loi la de Student à 5 et 30 degrés de liberté (utiliser dt). On utilisera la fonction lines et des couleurs différentes pour chaque densité. Ajouter une légende qui permet de repérer chaque densité (fonction legend). &gt; x &lt;- seq(-4,4,by=0.01) &gt; plot(x,dnorm(x),type=&quot;l&quot;) &gt; abline(v=0,lty=2) &gt; lines(x,dt(x,5),col=2) &gt; lines(x,dt(x,30),col=3) &gt; legend(&quot;topleft&quot;,legend=c(&quot;normal&quot;,&quot;Student(5)&quot;,&quot;Student(30)&quot;), + col=1:3,lty=1) Exercice 1.3 (Tâches solaires) Importer la série taches_solaires.csv qui donne, date par date, un nombre de taches solaires observées. &gt; taches &lt;- read.table(&quot;taches_solaires.csv&quot;,sep=&quot;;&quot;,header=TRUE,dec=&quot;,&quot;) A l’aide de la fonction cut_interval du tidyverse créer un facteur qui sépare l’intervalle d’années d’observation en 8 intervalles de tailles à peu près égales. On appellera periode ce facteur. &gt; library(tidyverse) &gt; periode &lt;- cut_interval(taches$annee,n=8) Utiliser les levels suivants pour le facteur periode. &gt; couleurs &lt;- c(&quot;yellow&quot;, &quot;magenta&quot;, &quot;orange&quot;, &quot;cyan&quot;, + &quot;grey&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;) &gt; levels(periode) &lt;- couleurs Expliquer la sortie de la fonction &gt; coordx &lt;- seq(along=taches[,1]) On crée une séquence avec un pas de 1 de longueur égale à la dimension de taches[,1]. Visualiser la série du nombre de taches en utilisant une couleur différente pour chaque période. &gt; plot(coordx,taches[,1],xlab=&quot;Temps&quot;,ylab=&quot;Nombre de taches&quot;, + col=periode,type=&quot;p&quot;,pch=&quot;+&quot;) Exercice 1.4 (Layout) On reprend le jeu de données sur l’ozone. A l’aide de la fonction layout séparer la fenêtre graphique en deux lignes avec un graphe sur la première ligne (nuage de points maxO3 vs T12) 2 graphes sur la deuxième colonne (histogramme de T12 et boxplot de maxO3). &gt; layout(matrix(c(1,1,2,3), 2, 2, byrow = TRUE)) &gt; plot(maxO3~T12,data=ozone) &gt; hist(ozone$T12) &gt; boxplot(ozone$maxO3) 1.2 La grammaire ggplot2 Ce package propose de définir des graphes sur R en utilisant une grammaire des graphiques (tout comme dplyr pour manipuler les données). On peut trouver de la documentation sur ce package aux url http://ggplot2.org et https://ggplot2-book.org. 1.2.1 Premiers graphes ggplot2 Nous considérons un sous échantillon du jeu de données diamonds du package ggplot2 (qui se trouve dans le tidyverse). &gt; library(tidyverse) &gt; set.seed(1234) &gt; diamonds2 &lt;- diamonds[sample(nrow(diamonds),5000),] &gt; summary(diamonds2) ## carat cut color clarity depth ## Min. :0.2000 Fair : 158 D: 640 SI1 :1189 Min. :43.00 ## 1st Qu.:0.4000 Good : 455 E: 916 VS2 :1157 1st Qu.:61.10 ## Median :0.7000 Very Good:1094 F: 900 SI2 : 876 Median :61.80 ## Mean :0.7969 Premium :1280 G:1018 VS1 : 738 Mean :61.76 ## 3rd Qu.:1.0400 Ideal :2013 H: 775 VVS2 : 470 3rd Qu.:62.50 ## Max. :4.1300 I: 481 VVS1 : 326 Max. :71.60 ## J: 270 (Other): 244 ## table price x y ## Min. :49.00 Min. : 365 Min. : 0.000 Min. :3.720 ## 1st Qu.:56.00 1st Qu.: 945 1st Qu.: 4.720 1st Qu.:4.720 ## Median :57.00 Median : 2376 Median : 5.690 Median :5.700 ## Mean :57.43 Mean : 3917 Mean : 5.728 Mean :5.731 ## 3rd Qu.:59.00 3rd Qu.: 5294 3rd Qu.: 6.530 3rd Qu.:6.520 ## Max. :95.00 Max. :18757 Max. :10.000 Max. :9.850 ## ## z ## Min. :0.000 ## 1st Qu.:2.920 ## Median :3.520 ## Mean :3.538 ## 3rd Qu.:4.030 ## Max. :6.430 ## &gt; help(diamonds) Pour un jeu de données considéré, un graphe ggplot est défini à partir de couches que l’on assemblera avec l’opérateur +. Il faut a minima spécifier : les données les variables que l’on souhaite représenter le type de représentation (nuage de points, boxplot…). Il existe un verbe pour définir chacune de ces couches : ggplot pour les données aes (aesthetics) pour les variables geom_ pour le type de représentation. On peut obtenir le nuage de points carat vs price avec la fonction plot : &gt; plot(price~carat,data=diamonds2) Avec ggplot, on va faire &gt; ggplot(diamonds2) #rien &gt; ggplot(diamonds2)+aes(x=carat,y=price) #rien &gt; ggplot(diamonds2)+aes(x=carat,y=price)+geom_point() #bon Exercice 1.5 (Permiers graphes ggplot) Tracer l’histogramme de la variable carat (utiliser geom_histogram). Tracer l’histogramme de la variable carat avec 10 classes (help(geom_histogram)). Tracer le diagramme à batons de la variable cut (utiliser geom_bar). &gt; ggplot(diamonds2)+aes(x=carat)+geom_histogram() &gt; ggplot(diamonds2)+aes(x=carat)+geom_histogram(bins=10) &gt; ggplot(diamonds2)+aes(x=cut)+geom_bar() La syntaxe ggplot se construit à partir d’éléments indépendants qui définissent la grammaire de ggplot. Les principaux verbes sont : Data (ggplot) : les données au format dataframe ou tibble Aesthetics (aes) : pour sépecifier les variables à représenter dans le graphe. Geometrics (geom_...) : le type de graphe (nuage de points, histogramme…). Statistics (stat_...) : utile pour spécifier des transformations des données nécessaires pour obtenir le graphe. Scales (scale_...) : pour controler les paramètres permettant d’affiner le graphe (changement de couleurs, paramètres des axes…). Tous ces éléments sont reliés avec le symbole +. 1.2.2 Data et aesthetics Ces deux verbes sont à utiliser pour tous les graphes ggplot. Le verbe ggplot servira à définir le jeu de données que l’on souhaite utiliser. Si le code est bien fait, nous n’aurons plus à utiliser le nom du jeu de données par la suite pour construire le graphe. Le verbe aes est quant à lui utile pour sépcifier le nom des variables que l’on souhaite visualiser. Par exemple, pour le nuage de points price vs carat la syntaxe devra débuter par &gt; ggplot(diamonds2)+aes(x=carat,y=price) Les variables peuvent également être utilisées pour colorier des points ou des barres, définir des tailles… Dans ce cas on pourra renseigner les arguments color, size, fill dans la fonction aes. Par exemple &gt; ggplot(diamonds2)+aes(x=carat,y=price,color=cut) 1.2.3 Geometrics Ce verbe décrira le type de représentation souhaitée. Pour un nuage de points, on utilisera par exemple geom_point : &gt; ggplot(diamonds2)+aes(x=carat,y=price,color=cut)+geom_point() On observe que ggplot ajoute la légende automatiquement. Voici les principaux exemples de geometrics : Table 1.1: Principaux geometrics Geom Description Aesthetics geom_point() nuage de points x, y, shape, fill geom_line() Ligne (ordonnée selon x) x, y, linetype geom_abline() Ligne slope, intercept geom_path() Ligne (ordonnée par l’index) x, y, linetype geom_text() Texte x, y, label, hjust, vjust geom_rect() Rectangle xmin, xmax, ymin, ymax, fill, linetype geom_polygon() Polygone x, y, fill, linetype geom_segment() Segment x, y, xend, yend, fill, linetype geom_bar() Diaggramme en barres x, fill, linetype, weight geom_histogram() Histogramme x, fill, linetype, weight geom_boxplot() Boxplot x, fill, weight geom_density() Densité x, y, fill, linetype geom_contour() Lignes de contour x, y, fill, linetype geom_smooth() Lisseur (linéaire ou non linéaire) x, y, fill, linetype Tous color, size, group Exercice 1.6 (Diagrammes en barres) Tracer le diagramme en barres de la variable cut avec des barres bleues. Tracer le diagramme en barres de la variable cut avec une couleur pour chaque modalité de cut ainsi qu’une légende qui permet de repérer la couleur. Tracer le diagramme en barres de la variable cut avec une couleur pour chaque modalité que vous choisirez (et sans légende). &gt; ggplot(diamonds2)+aes(x=cut)+geom_bar(fill=&quot;blue&quot;) &gt; ggplot(diamonds2)+aes(x=cut,fill=cut)+geom_bar() &gt; ggplot(diamonds2)+aes(x=cut)+geom_bar(fill=c(&quot;blue&quot;,&quot;red&quot;,&quot;green&quot;,&quot;yellow&quot;,&quot;black&quot;)) 1.2.4 Statistics Certains graphes nécessitent des calculs d’indicateurs statistiques pour être tracé. C’est par exemple le cas pour le diagamme en barres et l’histogramme où il faut calculer des hauteurs des barres. Les transformations simples peuvent se faire rapidement, on peut par exemple tracer la fonction sinus avec &gt; D &lt;- data.frame(X=seq(-2*pi,2*pi,by=0.01)) &gt; ggplot(D)+aes(x=X,y=sin(X))+geom_line() La transformation est spécifiée dans la fonction aes. Pour des transformations plus complexes, nous devons utiliser des statistics. Une fonction stat permet de définir des nouvelles variables à partir du jeu de données initial, il est ensuite possible de représenter ces nouvelles variables. Par exemple, la fonction stat_bin, qui est utilisée par défaut pour construire des histogrammes, produit les variables suivantes : count, le nombre d’observations dans chaque classes. density, la valeur de la densité des observations dans chaque classe (fréquance divisée par largeur de la classe). x, le centre de la classe. Par défaut geom_histogram fait appel à cette fonction stat_binet représente sur l’axe \\(y\\) le nombre d’observations dans chaque classe (la variable count). &gt; ggplot(diamonds2)+aes(x=price)+geom_histogram(bins=40) Si on souhaite une autre variable issue de stat_bin, comme par exemple la densité, il faudra utiliser &gt; ggplot(diamonds2)+aes(x=price,y=..density..)+geom_histogram(bins=40) Il est possible d’utiliser les fonctions stat_ à la place des geom_ pour certaines représentations. Chaque fonction stat_ possède par défaut un geom_ et réciproquement. On peut par exemple obtenir le même graphe que précédemment avec &gt; ggplot(diamonds2)+aes(x=price,y=..density..)+stat_bin() Voici quelques exemple de fonctions stat_ Table 1.2: Exemples de statistics. Stat Description Paramètres stat_identity() aucune transformation stat_bin() Count binwidth, origin stat_density() Density adjust, kernel stat_smooth() Smoother method, se stat_boxplot() Boxplot coef stat et geom ne sont pas toujours simples à combiner. Nous recommandons d’utiliser geom lorsqu’on débute avec ggplot, les statisticspar défaut ne doivent en effet être changés que rarement. Exercice 1.7 (Diagramme en barres “très simple”…) On considère une variable qualitative \\(X\\) dont la loi est donnée par \\[P(X=red)=0.3,\\ P(X=blue)=0.2,\\ P(X=green)=0.4,\\ P(X=black)=0.1\\] Représenter cette distribution de probabilité avec un diagramme en barres. &gt; X &lt;- data.frame(X1=c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;black&quot;),prob=c(0.3,0.2,0.4,0.1)) &gt; ggplot(X)+aes(x=X1,y=prob,fill=X1)+geom_bar(stat=&quot;identity&quot;)+ + labs(fill=&quot;Couleur&quot;)+xlab(&quot;&quot;) Exercice 1.8 (Lissage) Représenter le lissage non linéaire de la variable price contre la variable carat à l’aide de geom_smooth puis de stat_smooth. Même question mais avec une ligne en pointillés à la place d’un trait plein. &gt; ggplot(diamonds2)+aes(x=carat,y=price)+geom_smooth(method=&quot;loess&quot;) &gt; ggplot(diamonds2)+aes(x=carat,y=price)+stat_smooth(method=&quot;loess&quot;) &gt; ggplot(diamonds2)+aes(x=carat,y=price)+geom_smooth(method=&quot;loess&quot;,linetype=&quot;dotted&quot;) &gt; ggplot(diamonds2)+aes(x=carat,y=price)+stat_smooth(method=&quot;loess&quot;,geom=&quot;point&quot;) 1.2.5 Scales Les échelles (scales) controlent tout un tas d’options telles que des changements de couleurs, d’échelles ou de limites d’axes, de symboles, etc… L’utilisation n’est pas simple et nécessite de la pratique. On utilise généralement ce verbe à la dernière étape de construction du graphe. La syntaxe est définie comme suit : début : scale_. ajout de l’aesthetics que l’on souhaite modifier (color, fill, x_). fin : nom de l’échelle (manual, identity…) Par exemple, &gt; ggplot(diamonds2)+aes(x=carat,y=price,color=cut)+geom_point()+ + scale_color_manual(values=c(&quot;Fair&quot;=&quot;black&quot;,&quot;Good&quot;=&quot;yellow&quot;, + &quot;Very Good&quot;=&quot;blue&quot;,&quot;Premium&quot;=&quot;red&quot;,&quot;Ideal&quot;=&quot;green&quot;)) Voici quelques exemples des principales échelles : Table 1.3: Exemples d’échelles aes Discret Continu Couleur (color et fill) brewer gradient - grey gradient2 - hue gradientn - identity - manual Position (x et y) discrete continous - date Forme shape - identity - manual Taille identity size - manual Nous présentons quelques exemples d’utilisation des échelles : Couleur dans un diagramme en barres &gt; p1 &lt;- ggplot(diamonds2)+aes(x=cut)+geom_bar(aes(fill=cut)) &gt; p1 On change la couleur en utilisant la palette Purples : &gt; p1+scale_fill_brewer(palette=&quot;Purples&quot;) Gradient de couleurs pour un nuage de points : &gt; p2 &lt;- ggplot(diamonds2)+aes(x=carat,y=price)+geom_point(aes(color=depth)) &gt; p2 On change le gradient de couleur &gt; p2+scale_color_gradient(low=&quot;red&quot;,high=&quot;yellow&quot;) Modification sur les axes &gt; p2+scale_x_continuous(breaks=seq(0.5,3,by=0.5))+ + scale_y_continuous(name=&quot;prix&quot;)+ + scale_color_gradient(&quot;Profondeur&quot;) 1.2.6 Group et facets ggplot permet de faire des représentations pour des groupes d’individus. On procède généralement de deux façons différentes : visualisation de sous groupes sur le même graphe, on utilise l’option group dans aes ; visualisation de sous groupes sur des graphes différents, on utilise le verbe facets. Représentons ici (sur le même graphe) le lisseur price vs carat pour chaque modalité de cut &gt; ggplot(diamonds2)+aes(x=carat,y=price,group=cut)+ + geom_smooth(method=&quot;loess&quot;) Pour obtenir cette représentation sur plusieurs fenêtres, on utilise &gt; ggplot(diamonds2)+aes(x=carat,y=price)+ + geom_smooth(method=&quot;loess&quot;)+facet_wrap(~cut) &gt; ggplot(diamonds2)+aes(x=carat,y=price)+ + geom_smooth(method=&quot;loess&quot;)+facet_wrap(~cut,nrow=1) facet_grid et facet_wrap font des choses proches mais divisent la fenêtre de façon différente : &gt; ggplot(diamonds2)+aes(x=carat,y=price)+geom_point()+ + geom_smooth(method=&quot;lm&quot;)+facet_grid(color~cut) &gt; ggplot(diamonds2)+aes(x=carat,y=price)+geom_point()+ + geom_smooth(method=&quot;lm&quot;)+facet_wrap(color~cut) 1.3 Compléments La syntaxe ggplot est définie selon le schéma : &gt; ggplot()+aes()+geom_()+scale_() Elle est très flexible, on peut par exemple spécifier les variables de aes dans les verbes ggplot ou geom_ : &gt; ggplot(diamonds2)+aes(x=carat,y=price)+geom_point() &gt; ggplot(diamonds2,aes(x=carat,y=price))+geom_point() &gt; ggplot(diamonds2)+geom_point(aes(x=carat,y=price)) Ceci peut se révéler très utile lorsqu’on utilise des aes différents dans les geom_. On peut aussi construire un graphe à l’aide de différents jeux de données : &gt; X &lt;- seq(-2*pi,2*pi,by=0.001) &gt; Y1 &lt;- cos(X) &gt; Y2 &lt;- sin(X) &gt; donnees1 &lt;- data.frame(X,Y1) &gt; donnees2 &lt;- data.frame(X,Y2) &gt; ggplot(donnees1)+geom_line(aes(x=X,y=Y1))+ + geom_line(data=donnees2,aes(x=X,y=Y2),color=&quot;red&quot;) Il existe d’autres fonctions ggplot : ggtitle pour ajouter un titre. ggsave pour sauver un graphe. theme_ pour changer le theme du graphe. &gt; p &lt;- ggplot(diamonds2)+aes(x=carat,y=price,color=cut)+geom_point() &gt; p+theme_bw() &gt; p+theme_classic() &gt; p+theme_grey() &gt; p+theme_bw() D’autres thèmes sont disponibles dans le package ggtheme. On pourra également parler de la fonction set_theme qui permet de préciser modifier le thème par défaut pour un document Markdown. 1.4 Quelques exercices supplémentaires Exercice 1.9 (Fonctions cosinus et sinus) Tracer les fonctions sinus et cosinus. On utilisera tout d’abord deux jeux de données : un pour le sinus, l’autre pour le cosinus. &gt; X &lt;- seq(-2*pi,2*pi,by=0.001) &gt; Y1 &lt;- cos(X) &gt; Y2 &lt;- sin(X) &gt; donnees1 &lt;- data.frame(X,Y1) &gt; donnees2 &lt;- data.frame(X,Y2) &gt; ggplot(donnees1)+geom_line(aes(x=X,y=Y1))+ + geom_line(data=donnees2,aes(x=X,y=Y2),color=&quot;red&quot;) Faire la même chose avec un jeu de données et deux appels à la fonction geom_line. On pourra ajouter une légende. &gt; donnees &lt;- data.frame(X,Y1,Y2) &gt; ggplot(donnees)+aes(x=X,y=Y1)+geom_line()+ + geom_line(aes(y=Y2),color=&quot;red&quot;) &gt; #ou pour la légende &gt; ggplot(donnees)+aes(x=X,y=Y1)+geom_line(aes(color=&quot;cos&quot;))+ + geom_line(aes(y=Y2,color=&quot;sin&quot;))+labs(color=&quot;Fonction&quot;) Faire la même chose avec un jeu de données et un seul appel à geom_line. On pourra utiliser la fonction gather du tidyverse. &gt; df &lt;- data.frame(X,cos=Y1,sin=Y2) &gt; df1 &lt;- df %&gt;% pivot_longer(cols=c(cos,sin), + names_to = &quot;Fonction&quot;, + values_to = &quot;value&quot;) &gt; #ou &gt; df1 &lt;- df %&gt;% pivot_longer(cols=-X, + names_to = &quot;Fonction&quot;, + values_to = &quot;value&quot;) &gt; ggplot(df1)+aes(x=X,y=value,color=Fonction)+geom_line() Tracer les deux fonctions sur deux fenêtres graphiques (utiliser facet_wrap). &gt; ggplot(df1)+aes(x=X,y=value)+geom_line()+facet_wrap(~Fonction) Faire la même chose avec la fonction grid.arrange du package gridExtra. &gt; library(gridExtra) &gt; p1 &lt;- ggplot(donnees1)+aes(x=X,y=Y1)+geom_line() &gt; p2 &lt;- ggplot(donnees2)+aes(x=X,y=Y2)+geom_line() &gt; grid.arrange(p1,p2,nrow=1) Exercice 1.10 (Différents graphes) On considère les données mtcars &gt; data(mtcars) &gt; summary(mtcars) ## mpg cyl disp hp ## Min. :10.40 Min. :4.000 Min. : 71.1 Min. : 52.0 ## 1st Qu.:15.43 1st Qu.:4.000 1st Qu.:120.8 1st Qu.: 96.5 ## Median :19.20 Median :6.000 Median :196.3 Median :123.0 ## Mean :20.09 Mean :6.188 Mean :230.7 Mean :146.7 ## 3rd Qu.:22.80 3rd Qu.:8.000 3rd Qu.:326.0 3rd Qu.:180.0 ## Max. :33.90 Max. :8.000 Max. :472.0 Max. :335.0 ## drat wt qsec vs ## Min. :2.760 Min. :1.513 Min. :14.50 Min. :0.0000 ## 1st Qu.:3.080 1st Qu.:2.581 1st Qu.:16.89 1st Qu.:0.0000 ## Median :3.695 Median :3.325 Median :17.71 Median :0.0000 ## Mean :3.597 Mean :3.217 Mean :17.85 Mean :0.4375 ## 3rd Qu.:3.920 3rd Qu.:3.610 3rd Qu.:18.90 3rd Qu.:1.0000 ## Max. :4.930 Max. :5.424 Max. :22.90 Max. :1.0000 ## am gear carb ## Min. :0.0000 Min. :3.000 Min. :1.000 ## 1st Qu.:0.0000 1st Qu.:3.000 1st Qu.:2.000 ## Median :0.0000 Median :4.000 Median :2.000 ## Mean :0.4062 Mean :3.688 Mean :2.812 ## 3rd Qu.:1.0000 3rd Qu.:4.000 3rd Qu.:4.000 ## Max. :1.0000 Max. :5.000 Max. :8.000 Tracer l’histograme de mpg (on fera varier le nombre de classes). &gt; ggplot(mtcars)+aes(x=mpg)+geom_histogram() &gt; ggplot(mtcars)+aes(x=mpg)+geom_histogram(bins=10) 2.Tracer l’histogramme de la densité. &gt; ggplot(mtcars)+aes(x=mpg,y=..density..)+geom_histogram(bins=10) Tracer le diagramme en barres de cyl. &gt; ggplot(mtcars)+aes(x=cyl)+geom_bar() Tracer le nuage de points disp vs mpg en utilisant une couleur différente pour chaque valeur de cyl. &gt; ggplot(mtcars)+aes(x=disp,y=mpg,color=cyl)+geom_point() &gt; ggplot(mtcars)+aes(x=disp,y=mpg,color=as.factor(cyl))+geom_point()+labs(color=&quot;cyl&quot;) Ajouter le lisseur linéaire sur le graphe. &gt; ggplot(mtcars)+aes(x=disp,y=mpg,color=as.factor(cyl))+geom_point()+ + geom_smooth(method=&quot;lm&quot;)+labs(color=&quot;cyl&quot;) Exercice 1.11 (Résidus pour régression simple) Générer un échantillon \\((x_i,y_i),i=1,\\dots,100\\) selon le modèle linéaire \\[Y_i=3+X_i+\\varepsilon_i\\] où \\(X_i\\) sont i.i.d. de loi uniforme sur \\([0,1]\\) et \\(\\varepsilon_i\\) sont i.i.d. de loi gaussienne \\(N(0,0.2^2)\\) (utiliser runif et rnorm). &gt; n &lt;- 100 &gt; X &lt;- runif(n) &gt; eps &lt;- rnorm(n,sd=0.2) &gt; Y &lt;- 3+X+eps &gt; D &lt;- data.frame(X,Y) Tracer le nuage de points Y vs X et ajouter le lisseur linéaire. On le fait d’abord “à la main” en calculant l’équation de la droite de régression. &gt; model &lt;- lm(Y~.,data=D) &gt; co &lt;- coef(model) &gt; D$fit &lt;- predict(model) &gt; co &lt;- coef(lm(Y~.,data=D)) &gt; ggplot(D)+aes(x=X,y=Y)+geom_point()+ + geom_abline(slope=co[2],intercept=co[1],color=&quot;blue&quot;) On peut avoir le tracé directement avec geom_smooth. &gt; ggplot(D)+aes(x=X,y=Y)+geom_point()+geom_smooth(method=&quot;lm&quot;) Représenter les résidus : on ajoutera une ligne verticale entre chaque point et la droite de lissage (utiliser geom_segment). &gt; ggplot(D)+aes(x=X,y=Y)+geom_point()+geom_smooth(method=&quot;lm&quot;)+ + geom_segment(aes(xend=X,yend=fit)) Exercice 1.12 (Challenge) Refaire la carte des températures du premier challenge (voir section 2.2.1) en utilisant leaflet. On utilisera la table construite dans le challenge 1 et la fonction addPolygons. On pourra également ajouter un popup qui permet de visualiser le nom du département ainsi que la température prévue lorsqu’on clique dessus. On considère les données diamonds. Tracer les graphes suivants (utiliser coord_flip pour le second). &gt; ggplot(data=diamonds) + geom_boxplot(aes(x=cut,y=carat,fill=cut)) &gt; ggplot(data=diamonds) + geom_boxplot(aes(x=cut,y=carat,fill=cut))+coord_flip() &gt; ggplot(data=diamonds) + geom_density(aes(x=carat,y=..density..)) + facet_grid(cut~.) Ajouter sur le troisième graphe les quartiles de la variable carat pour chaque valeur de cut. On utilisera une ligne verticale. &gt; Q1 &lt;- diamonds %&gt;% group_by(cut) %&gt;% + summarize(q1=quantile(carat,c(0.25)),q2=quantile(carat,c(0.5)), + q3=quantile(carat,c(0.75))) &gt; quantildf &lt;- Q1%&gt;% gather(key=&quot;alpha&quot;,value=&quot;quantiles&quot;,-cut) &gt; ggplot(data=diamonds) + geom_density(aes(x=carat,y=..density..))+ + facet_grid(cut~.) + + geom_vline(data=quantildf,aes(xintercept=quantiles),col=alpha(&quot;black&quot;,1/2)) En déduire le graphe suivant (on utilisera le package ggstance). &gt; library(ggstance) &gt; ggplot(data=diamonds) + + geom_boxploth(data=diamonds,aes(y=-0.5,x=carat,fill=cut)) + + geom_density(aes(x=carat,y=..density..)) + facet_grid(cut~.) + + geom_vline(data=quantildf,aes(xintercept=quantiles),col=alpha(&quot;black&quot;,1/2))+ + ylab(&quot;&quot;) &gt; knitr::opts_chunk$set(message=FALSE, warning=FALSE,cache=cache_carto) "],
["faire-des-cartes-avec-r.html", "Chapitre 2 Faire des cartes avec R 2.1 Le package ggmap 2.2 Cartes avec contours, le format shapefile 2.3 Cartes interactives avec leaflet", " Chapitre 2 Faire des cartes avec R De nombreuses données comportent des informations de géolocalisation. Il est alors naturel d’utiliser des cartes pour les visualiser. On peut généralement si’ntéresser à deux types de cartes : statiques : des cartes figées que l’on pourra exporter aux formats pdf ou png par exemple, ce type est généralement utilisé pour des rapports ; dynamiques ou interactives : des cartes que l’on pourra visualiser dans un navigateur et sur lesquelles on pourra zoomer ou obtenir des informations auxiliaires lorsu’on clique sur certaines parties de la carte. De nombreux packages R permettent de d’obtenir des cartes. Dans cette partie, on s’interessera aux packages ggmap et sf pour les cartes statiques et leaflet pour les cartes interactives. 2.1 Le package ggmap Nous montrons dans cette section comment récupérer des fonds de carte et ajouter quelques informations à l’aide de ggmap. Pour plus de détails sur ce package, on pourra consulter cet article pour plus de détails. ggmap permet de récupérer facilement des fonds de carte. Par exemple : &gt; library(ggmap) &gt; us &lt;- c(left = -125, bottom = 25.75, right = -67, top = 49) &gt; map &lt;- get_stamenmap(us, zoom = 5, maptype = &quot;toner-lite&quot;) &gt; ggmap(map) Pour l’Europe on fait &gt; europe &lt;- c(left = -12, bottom = 35, right = 30, top = 63) &gt; get_stamenmap(europe, zoom = 5,&quot;toner-lite&quot;) %&gt;% ggmap() On peut également changer le fond de carte &gt; get_stamenmap(europe, zoom = 5,&quot;toner-background&quot;) %&gt;% ggmap() Pour la france, on aura &gt; fr &lt;- c(left = -6, bottom = 41, right = 10, top = 52) &gt; get_stamenmap(fr, zoom = 5,&quot;toner-lite&quot;) %&gt;% ggmap() La fonction geocode de ggmapqui permettait de récupérer des latitudes et longitudes nécessite désormais une API, ce qui contraint son utilisation. Nous proposons d’utiliser la fonction suivante : &gt; if (!(require(jsonlite))) install.packages(&quot;jsonlite&quot;) &gt; mygeocode &lt;- function(adresses){ + # adresses est un vecteur contenant toutes les adresses sous forme de chaine de caracteres + nominatim_osm &lt;- function(address = NULL){ + ## details: http://wiki.openstreetmap.org/wiki/Nominatim + ## fonction nominatim_osm proposée par D.Kisler + if(suppressWarnings(is.null(address))) return(data.frame()) + tryCatch( + d &lt;- jsonlite::fromJSON( + gsub(&#39;\\\\@addr\\\\@&#39;, gsub(&#39;\\\\s+&#39;, &#39;\\\\%20&#39;, address), + &#39;http://nominatim.openstreetmap.org/search/@addr@?format=json&amp;addressdetails=0&amp;limit=1&#39;) + ), error = function(c) return(data.frame()) + ) + if(length(d) == 0) return(data.frame()) + return(c(as.numeric(d$lon), as.numeric(d$lat))) + } + tableau &lt;- t(sapply(adresses,nominatim_osm)) + colnames(tableau) &lt;- c(&quot;lon&quot;,&quot;lat&quot;) + return(tableau) + } Cette fonction permet de récupérer les latitudes et longitudes de lieux à spécifier : &gt; mygeocode(&quot;the white house&quot;) ## lon lat ## the white house -77.03655 38.8977 &gt; mygeocode(&quot;Paris&quot;) ## lon lat ## Paris 2.351462 48.8567 &gt; mygeocode(&quot;Rennes&quot;) ## lon lat ## Rennes -1.68002 48.11134 Exercice 2.1 (Populations des grandes villes de france) Récupérer les latitudes et longitudes de Paris, Lyon et Marseille et représenter ces 3 villes sur une carte de la france. &gt; V &lt;- c(&quot;Paris&quot;,&quot;Lyon&quot;,&quot;Marseille&quot;) &gt; A &lt;- mygeocode(V) &gt; A &lt;- A %&gt;% as_tibble() %&gt;% mutate(Villes=V) &gt; fr &lt;- c(left = -6, bottom = 41, right = 10, top = 52) &gt; fond &lt;- get_stamenmap(fr, zoom = 5,&quot;toner-lite&quot;) &gt; ggmap(fond)+geom_point(data=A,aes(x=lon,y=lat),color=&quot;red&quot;) Le fichier villes_fr.csv contient les populations des 30 plus grandes villes de france. Représenter à l’aide d’un point les 30 plus grandes villes de france. On fera varier la taille du point en fonction de la population en 2014. &gt; df &lt;- read_csv(&quot;villes_fr.csv&quot;) &gt; df$Commune &lt;- as.character(df$Commune) &gt; df$Commune[10] &lt;- &quot;Lille&quot; &gt; coord &lt;- mygeocode(as.character(df$Commune)) %&gt;% as_tibble() &gt; df1 &lt;- bind_cols(df,coord) &gt; ggmap(fond)+geom_point(data=df1,aes(x=lon,y=lat),color=&quot;red&quot;) &gt; ggmap(fond)+geom_point(data=df1,aes(x=lon,y=lat,size=`2014`),color=&quot;red&quot;) 2.2 Cartes avec contours, le format shapefile ggmap permet de récupérer facilement des fonds de cartes et de placer des points dessus avec la syntaxe ggplot. Cependant, de nombreuses fonctions de ca package nécessitent une API et il est difficile de définir des contours (frontières de pays, départements ou régions) avec ggmap. Nous proposons ici de présenter brièvement le package sf qui va nous permettre de créer des cartes “avancées”, en gérant les contours à l’aide d’objets particuliers mais aussi en prenant en compte différents systèmes de coordonnées. En effet, la terre n’est pas plate… mais une carte est souvent visualisée en 2D, il faut par conséquent réaliser des projections pour représenter des lieux définis par une coordonnée (comme la latitue et la longitude) sur une carte 2D. Ces projections sont généralement gérées par les packages qui permettent de faire de la cartographie comme sf.On pourra trouver de la documentation sur ce package aux url suivantes : https://statnmap.com/fr/2018-07-14-initiation-a-la-cartographie-avec-sf-et-compagnie/ dans les vignettes sur la page du cran de ce package : https://cran.r-project.org/web/packages/sf/index.html Ce package propose de définir un nouveau format sf adapté à la cartographie. Regardons par exemple l’objet nc &gt; library(sf) &gt; nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;), quiet = TRUE) &gt; class(nc) ## [1] &quot;sf&quot; &quot;data.frame&quot; &gt; nc ## Simple feature collection with 100 features and 14 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 ## CRS: 4267 ## First 10 features: ## AREA PERIMETER CNTY_ CNTY_ID NAME FIPS FIPSNO CRESS_ID BIR74 SID74 ## 1 0.114 1.442 1825 1825 Ashe 37009 37009 5 1091 1 ## 2 0.061 1.231 1827 1827 Alleghany 37005 37005 3 487 0 ## 3 0.143 1.630 1828 1828 Surry 37171 37171 86 3188 5 ## 4 0.070 2.968 1831 1831 Currituck 37053 37053 27 508 1 ## 5 0.153 2.206 1832 1832 Northampton 37131 37131 66 1421 9 ## 6 0.097 1.670 1833 1833 Hertford 37091 37091 46 1452 7 ## 7 0.062 1.547 1834 1834 Camden 37029 37029 15 286 0 ## 8 0.091 1.284 1835 1835 Gates 37073 37073 37 420 0 ## 9 0.118 1.421 1836 1836 Warren 37185 37185 93 968 4 ## 10 0.124 1.428 1837 1837 Stokes 37169 37169 85 1612 1 ## NWBIR74 BIR79 SID79 NWBIR79 geometry ## 1 10 1364 0 19 MULTIPOLYGON (((-81.47276 3... ## 2 10 542 3 12 MULTIPOLYGON (((-81.23989 3... ## 3 208 3616 6 260 MULTIPOLYGON (((-80.45634 3... ## 4 123 830 2 145 MULTIPOLYGON (((-76.00897 3... ## 5 1066 1606 3 1197 MULTIPOLYGON (((-77.21767 3... ## 6 954 1838 5 1237 MULTIPOLYGON (((-76.74506 3... ## 7 115 350 2 139 MULTIPOLYGON (((-76.00897 3... ## 8 254 594 2 371 MULTIPOLYGON (((-76.56251 3... ## 9 748 1190 2 844 MULTIPOLYGON (((-78.30876 3... ## 10 160 2038 5 176 MULTIPOLYGON (((-80.02567 3... Ces données contiennent des informations sur les morts subites de nourissons dans des villes de Caroline du Nord. On remarque que l’objet nc est au format sf et data.frame. On peut donc l’utiliser comme un data.frame classique. Le format sf permet l’ajout d’une colonne particulière (geometry) qui délimitera les villes à l’aide de polygones. Une fois l’objet obtenu au format sf, il est facile de visualiser la carte avec un plot classique &gt; plot(st_geometry(nc)) ou en utilisant le verbe geom_sf si on veut faire du ggplot &gt; ggplot(nc)+geom_sf() Il devient dès lors facile de colorier des villes et d’ajouter leurs noms : &gt; ggplot(nc[1:3,]) + + geom_sf(aes(fill = AREA)) + + geom_sf_label(aes(label = NAME)) La colonne geometry de nc est au format MULTIPOLYGON, elle permettra donc de délimiter les frontières des villes. Si maintenant on souhaite représenter une ville à l’aide d’un point défini par sa latitude et longitude, il va falloir modifier le format de cette colonne geometry. On peut le faire de la manière suivante : On récupère les latitudes et longitudes de chaque ville : &gt; coord.ville.nc &lt;- mygeocode(paste(as.character(nc$NAME),&quot;NC&quot;)) &gt; coord.ville.nc &lt;- as.data.frame(coord.ville.nc) &gt; names(coord.ville.nc) &lt;- c(&quot;lon&quot;,&quot;lat&quot;) On met ces coordonnées au format MULTIPOINT &gt; coord.ville1.nc &lt;- coord.ville.nc %&gt;% + filter(lon&lt;=-77 &amp; lon&gt;=-85 &amp; lat&gt;=33 &amp; lat&lt;=37) %&gt;% + as.matrix() %&gt;% st_multipoint() %&gt;% st_geometry() &gt; coord.ville1.nc &lt;- coord.ville.nc %&gt;% + filter(lon&lt;=-77 &amp; lon&gt;=-85 &amp; lat&gt;=33 &amp; lat&lt;=37) %&gt;% + as.matrix() %&gt;% st_multipoint() %&gt;% st_geometry() %&gt;% st_cast(to=&quot;POINT&quot;) &gt; coord.ville1.nc ## Geometry set for 79 features ## geometry type: POINT ## dimension: XY ## bbox: xmin: -84.08862 ymin: 33.93323 xmax: -77.01151 ymax: 36.503 ## CRS: NA ## First 5 geometries: On indique que ces coordonnées sont des latitudes et longitude et on ajoute la colonne aux données initiales &gt; st_crs(coord.ville1.nc) &lt;- 4326 On peut enfin représenter la carte avec les frontières et les points : &gt; ggplot(nc)+geom_sf()+geom_sf(data=coord.ville1.nc) Le package sf possède également des fonctions très utiles pour traiter des données cartographiques, on peut citer par exemple : st_distance qui permet de calculer des distances entre coordonnées ; st_centroid pour calculer le centre d’une région. On peut ainsi représenter les centres des villes délimitées par les polygones des données nc avec &gt; nc2 &lt;- nc %&gt;% mutate(centre=st_centroid(nc)$geometry) &gt; ggplot(nc2)+geom_sf()+geom_sf(aes(geometry=centre)) Exercice 2.2 (Première carte avec sf) Nous nous servons de la carte GEOFLAR proposée par l’Institut Géographique National pour récupérer un fond de carte contenant les frontières des départements français. Cette carte est disponible sur le site http: //professionnels.ign.fr/ au format shapefile, elle se trouve dans l’archive dpt.zip. Il faut décompresser pour reproduire la carte. Grâce au package sf, cette carte, contenue dans la série de fichiers departement du répertoire dpt, peut être importée dans un objet R : &gt; dpt &lt;- read_sf(&quot;dpt&quot;) &gt; ggplot(dpt) + geom_sf() Refaire la carte de l’exercice 2.1 sur ce fond de carte. &gt; coord.ville1 &lt;- data.frame(df1[,14:15]) %&gt;% + as.matrix() %&gt;% st_multipoint() %&gt;% st_geometry() &gt; &gt; coord.ville2 &lt;- st_cast(coord.ville1, to = &quot;POINT&quot;) &gt; coord.ville1 ## Geometry set for 1 feature ## geometry type: MULTIPOINT ## dimension: XY ## bbox: xmin: -4.486009 ymin: 42.69853 xmax: 7.750713 ymax: 50.63657 ## CRS: NA &gt; coord.ville2 ## Geometry set for 30 features ## geometry type: POINT ## dimension: XY ## bbox: xmin: -4.486009 ymin: 42.69853 xmax: 7.750713 ymax: 50.63657 ## CRS: NA ## First 5 geometries: &gt; st_geometry(df1) &lt;- coord.ville2 &gt; st_crs(df1) &lt;- 4326 &gt; ggplot(dpt)+geom_sf(fill=&quot;white&quot;)+ + geom_sf(data=df1,aes(size=`2014`),color=&quot;red&quot;)+theme_void() Exercice 2.3 (Visualisation de taux de chômage avec sf) Nous souhaitons visualiser graphiquement les différences de taux de chômage par département entre deux années. Pour cela, nous disposons de chaque taux mesuré aux premiers trimestres des années 2006 et 2011 (variables TCHOMB1T06, TCHOMB1T11) qui se trouvent dans le jeu de données tauxchomage.csv Importer le jeu de données. &gt; chomage &lt;- read_delim(&quot;tauxchomage.csv&quot;,delim=&quot;;&quot;) Faire la jointure de cette table avec celle des départements. On pourra utiliser inner_join. &gt; dpt &lt;- read_sf(&quot;dpt&quot;) &gt; dpt2 &lt;- inner_join(dpt,chomage,by=&quot;CODE_DEPT&quot;) Comparer les taux de chomage en 2006 et 2011 (on le fera une carte avec les taux en 2006 et une autre avec les taux en 2011). &gt; dpt3 &lt;- dpt2 %&gt;% select(A2006=TCHOMB1T06,A2011=TCHOMB1T11,geometry) %&gt;% + gather(&quot;Annee&quot;,&quot;TxChomage&quot;,-geometry) &gt; ggplot(dpt3) + aes(fill = TxChomage)+geom_sf() + + facet_wrap(~Annee, nrow = 1)+ + scale_fill_gradient(low=&quot;white&quot;,high=&quot;brown&quot;)+theme_bw() 2.2.1 Challenge 1 : carte des températures avec ggmap On souhaite ici faire une carte permettant de visualiser les température en France à un moment donné. Les données se trouvent sur le site des données publiques de meteo france. On peut notamment récupérer les températures observées dans certaines stations en france ainsi que la géolocalisation de ces stations. Importer les 2 bases nécessaires. On pourra les lire directment sur le site. Convertir les degrés Kelvin en degrés Celsius et faire la jointure de ces bases. &gt; donnees &lt;- read_delim(&quot;https://donneespubliques.meteofrance.fr/donnees_libres/Txt/Synop/synop.2020052415.csv&quot;,delim=&quot;;&quot;,col_types = cols(t=col_double())) &gt; station &lt;- read_delim(&quot;https://donneespubliques.meteofrance.fr/donnees_libres/Txt/Synop/postesSynop.csv&quot;,delim=&quot;;&quot;) &gt; donnees$t &lt;- donnees$t-273.15 #on passe en degrés celcius &gt; temp &lt;- donnees %&gt;% select(numer_sta,t) &gt; names(temp)[1] &lt;- c(&quot;ID&quot;) &gt; D &lt;- inner_join(temp, station, by = c(&quot;ID&quot;)) Eliminer les station d’outre mer (on pourra conserver uniquement les stations qui ont une longitude entre -20 et 25). On appellera ce tableau station1. Visualiser les stations sur la carte contenant les frontières des départements français. &gt; station1 &lt;- D %&gt;% filter(Longitude&lt;25 &amp; Longitude&gt;-20) %&gt;% na.omit() &gt; station4326 &lt;- st_multipoint(as.matrix(station1[,5:4])) %&gt;% st_geometry() &gt; st_crs(station4326) &lt;- 4326 &gt; ggplot(dpt) + geom_sf()+geom_sf(data=station4326) Créer un dataframe au format sf qui contient les températures des stations ainsi que leurs coordonnées dans la colonne geometry. On pourra commencer avec &gt; station2 &lt;- station1 %&gt;% select(Longitude,Latitude) %&gt;% + as.matrix() %&gt;% st_multipoint() %&gt;% st_geometry() &gt; st_crs(station2) &lt;- 4326 &gt; station2 &lt;- st_cast(station2, to = &quot;POINT&quot;) &gt; df &lt;- data.frame(temp=station1$t) &gt; st_geometry(df) &lt;- station2 Représenter les stations sur une carte de france. On pourra mettre un point de couleur différente en fonction de la température. &gt; ggplot(dpt) + geom_sf(fill=&quot;white&quot;)+ + geom_sf(data=df,aes(color=temp),size=2)+ + scale_color_continuous(low=&quot;yellow&quot;,high=&quot;red&quot;) On obtient les cordonnées des centroïdes des départements à l’aide de &gt; centro &lt;- st_centroid(dpt$geometry) &gt; centro &lt;- st_transform(centro,crs=4326) On déduit les distances entre ces centroïdes et les stations avec (df étant la table sf obtenue à la question 3). &gt; DD &lt;- st_distance(df,centro) Prédire la température de chaque département à l’aide de la règle du 1 plus proche voisin. &gt; NN &lt;- apply(DD,2,order)[1,] &gt; t_prev &lt;- station1[NN,2] Colorier les départements en fonction de la température prédite dans le département. On pourra faire varier le dégradé de couleur du jaune (pour les faibles températures) au rouge (pour les fortes). &gt; dpt1 &lt;- dpt %&gt;% mutate(t_prev=as.matrix(t_prev)) &gt; ggplot(dpt1) + geom_sf(aes(fill=t_prev)) + + scale_fill_continuous(low=&quot;yellow&quot;,high=&quot;red&quot;)+theme_void() 2.3 Cartes interactives avec leaflet Leaflet est un package permettant de faire de la cartographie ineractive. On pourra consulter un descriptif synthétique ici. Le principe est similaire à ce qui a été présenté précédemment : les cates sont construites à partie de couches qui se superposent. Un fond de carte s’obtient avec les fonctions leaflet et addTiles &gt; library(leaflet) &gt; leaflet() %&gt;% addTiles() On dispose de plusieurs styles de fonds de cartes (quelques exemples ici) : &gt; Paris &lt;- mygeocode(&quot;paris&quot;) &gt; m2 &lt;- leaflet() %&gt;% setView(lng = Paris[1], lat = Paris[2], zoom = 12) %&gt;% + addTiles() &gt; m2 %&gt;% addProviderTiles(&quot;Stamen.Toner&quot;) &gt; m2 %&gt;% addProviderTiles(&quot;Wikimedia&quot;) &gt; m2 %&gt;% addProviderTiles(&quot;Esri.NatGeoWorldMap&quot;) &gt; m2 %&gt;% + addProviderTiles(&quot;Stamen.Watercolor&quot;) %&gt;% + addProviderTiles(&quot;Stamen.TonerHybrid&quot;) Il est fréquemment utile de repérer des lieux sur une carte à l’aide de symboles. On pourra effectuer cela à l’aide des fonctions addMarkers et addCircles… &gt; data(quakes) &gt; leaflet(data = quakes[1:20,]) %&gt;% addTiles() %&gt;% + addMarkers(~long, ~lat, popup = ~as.character(mag)) Le caractère interactif de la carte permet d’ajouter de l’information lorsqu’on clique sur un marker (grâce à l’option popup). On peut également ajouter des popups qui contiennent plus d’information, voire des liens vers des sites web : &gt; content &lt;- paste(sep = &quot;&lt;br/&gt;&quot;, + &quot;&lt;b&gt;&lt;a href=&#39;http://www.samurainoodle.com&#39;&gt;Samurai Noodle&lt;/a&gt;&lt;/b&gt;&quot;, + &quot;606 5th Ave. S&quot;, + &quot;Seattle, WA 98138&quot; + ) &gt; &gt; leaflet() %&gt;% addTiles() %&gt;% + addPopups(-122.327298, 47.597131, content, + options = popupOptions(closeButton = FALSE) + ) Exercice 2.4 (Popup avec leaflet) Placer un popup localisant l’Université Rennes 2 (Campus Villejean). On ajoutera un lien renvoyant sur le site de l’Université. &gt; R2 &lt;- mygeocode(&quot;Universite Rennes 2 Villejean&quot;) %&gt;% as_tibble() &gt; info &lt;- paste(sep = &quot;&lt;br/&gt;&quot;, + &quot;&lt;b&gt;&lt;a href=&#39;https://www.univ-rennes2.fr&#39;&gt;Universite Rennes 2&lt;/a&gt;&lt;/b&gt;&quot;, + &quot;Campus Villejean&quot;) &gt; &gt; &gt; leaflet() %&gt;% addTiles() %&gt;% + addPopups(R2[1]$lon, R2[2]$lat, info,options = popupOptions(closeButton = FALSE)) 2.3.1 Challenge 2 : Visualisation des stations velib à Paris Plusieurs villes dans le monde ont accepté de mettre en ligne les données sur l’occupation des stations velib. Ces données sont facilement accessibles et mises à jour en temps réel. On dispose généralement de la taille et la localisation des stations, la proportion de vélos disponibles… Il est possible de requêter (entre autres) : sur les données Decaux sur Open data Paris sur vlstats pour des données mensuelles ou historiques ou encore sur Velib pour obtenir des fichiers qui sont rafraichis régulièrement. Récupérer les données actuelles de velib disponibles pour la ville de Paris : https://opendata.paris.fr/explore/dataset/velib-disponibilite-en-temps-reel/information/. On pourra utiliser la fonction url dans read.csv. &gt; lien &lt;- &quot;https://opendata.paris.fr/explore/dataset/velib-disponibilite-en-temps-reel/ + download/?format=csv&amp;timezone=Europe/Berlin&amp;use_labels_for_header=true&quot; &gt; sta.Paris &lt;- read_delim(lien,delim=&quot;;&quot;) Décrire les variables du jeu de données. Nous avons de l’information sur la disponibilité, le remplissage… de stations velib parisiennes. Créer les une variable latitude et une variable longitude à partir de la variable geo. &gt; sta.Paris1 &lt;- sta.Paris %&gt;% separate(`Coordonnées géographiques`, + into=c(&quot;lat&quot;,&quot;lon&quot;),sep=&quot;,&quot;) %&gt;% + mutate(lat=as.numeric(lat),lon=as.numeric(lon)) Visualiser les positions des stations sur une carte leaflet. &gt; map.velib1 &lt;- leaflet(data = sta.Paris1) %&gt;% + addTiles() %&gt;% + addCircleMarkers(~ lon, ~ lat,radius=3, + stroke = FALSE, fillOpacity = 0.5,color=&quot;red&quot; + ) &gt; &gt; map.velib1 Ajouter un popup qui permet de connaitre le nombre de vélos disponibles (électriques+mécanique) quand on clique sur la station (on pourra utiliser l’option popup dans la fonction addCircleMarkers). &gt; map.velib2 &lt;- leaflet(data = sta.Paris1) %&gt;% + addTiles() %&gt;% + addCircleMarkers(~ lon, ~ lat,radius=3,stroke = FALSE, + fillOpacity = 0.7,color=&quot;red&quot;, + popup = ~ sprintf(&quot;&lt;b&gt; Vélos dispos: %s&lt;/b&gt;&quot;, + as.character(`Nombre total vélos disponibles`))) &gt; &gt; #ou sans sprintf &gt; &gt; map.velib2 &lt;- leaflet(data = sta.Paris1) %&gt;% + addTiles() %&gt;% + addCircleMarkers(~ lon, ~ lat,radius=3,stroke = FALSE, fillOpacity = 0.7,color=&quot;red&quot;, + popup = ~ paste(&quot;Vélos dispos :&quot;, + as.character(`Nombre total vélos disponibles`))) &gt; &gt; map.velib2 Ajouter la nom de la station dans le popup. &gt; map.velib3 &lt;- leaflet(data = sta.Paris1) %&gt;% + addTiles() %&gt;% + addCircleMarkers(~ lon, ~ lat,radius=3,stroke = FALSE, + fillOpacity = 0.7,color=&quot;red&quot;, + popup = ~ paste(as.character(`Nom station`),&quot;, Vélos dispos :&quot;, + as.character(`Nombre total vélos disponibles`), + sep=&quot;&quot;)) &gt; &gt; map.velib3 Faire de même en utilisant des couleurs différentes en fonction de la proportion de vélos disponibles dans la station. On pourra utiliser les palettes de couleur &gt; ColorPal1 &lt;- colorNumeric(scales::seq_gradient_pal(low = &quot;#132B43&quot;, high = &quot;#56B1F7&quot;, + space = &quot;Lab&quot;), domain = c(0,1)) &gt; ColorPal2 &lt;- colorNumeric(scales::seq_gradient_pal(low = &quot;red&quot;, high = &quot;black&quot;, + space = &quot;Lab&quot;), domain = c(0,1)) &gt; map.velib4 &lt;- leaflet(data = sta.Paris1) %&gt;% + addTiles() %&gt;% + addCircleMarkers(~ lon, ~ lat,radius=3,stroke = FALSE, fillOpacity = 0.7, + color=~ColorPal1(`Nombre total vélos disponibles`/ + `Capacité de la station`), + popup = ~ paste(as.character(`Nom station`),&quot;, Vélos dispos :&quot;, + as.character(`Nombre total vélos disponibles`), + sep=&quot;&quot;)) &gt; &gt; map.velib4 &gt; map.velib5 &lt;- leaflet(data = sta.Paris1) %&gt;% + addTiles() %&gt;% + addCircleMarkers(~ lon, ~ lat,stroke = FALSE, fillOpacity = 0.7, + color=~ColorPal2(`Nombre total vélos disponibles`/ + `Capacité de la station`), + radius=~(`Nombre total vélos disponibles`/ + `Capacité de la station`)*8, + popup = ~ paste(as.character(`Nom station`),&quot;, Vélos dispos :&quot;, + as.character(`Nombre total vélos disponibles`), + sep=&quot;&quot;)) &gt; &gt; map.velib5 Créer une fonction local.station qui permette de visualiser quelques stations autours d’une station choisie. &gt; nom.station &lt;- &quot;Jussieu - Fossés Saint-Bernard&quot; &gt; local.station &lt;- function(nom.station){ + df &lt;- sta.Paris1 %&gt;% filter(`Nom station`==nom.station) + leaflet(data = sta.Paris1) %&gt;% setView(lng=df$lon,lat=df$lat,zoom=15) %&gt;% + addTiles() %&gt;% + addCircleMarkers(~ lon, ~ lat,stroke = FALSE, fillOpacity = 0.7, + popup = ~ paste(as.character(`Nom station`),&quot;, Vélos dispos :&quot;, + as.character(`Nombre total vélos disponibles`), + sep=&quot;&quot;)) %&gt;% + addMarkers(lng=df$lon,lat=df$lat, + popup = ~ paste(nom.station,&quot;, Vélos dispos :&quot;, + as.character(df$`Nombre total vélos disponibles`), + sep=&quot;&quot;), + popupOptions = popupOptions(noHide = T)) + } La fonction devra par exemple renvoyer &gt; local.station(&quot;Jussieu - Fossés Saint-Bernard&quot;) &gt; local.station(&quot;Gare Montparnasse - Arrivée&quot;) 2.3.2 Carte des températures avec leaflet Exercice 1.12 (Challenge) Refaire la carte des températures du premier challenge (voir section 2.2.1) en utilisant leaflet. On utilisera la table construite dans le challenge 1 et la fonction addPolygons. On pourra également ajouter un popup qui permet de visualiser le nom du département ainsi que la température prévue lorsqu’on clique dessus. &gt; dpt2 &lt;- st_transform(dpt1, crs = 4326) &gt; dpt2$t_prev &lt;- round(dpt2$t_prev) &gt; pal &lt;- colorNumeric(scales::seq_gradient_pal(low = &quot;yellow&quot;, high = &quot;red&quot;, + space = &quot;Lab&quot;), domain = dpt2$t_prev) &gt; m &lt;- leaflet() %&gt;% addTiles() %&gt;% + addPolygons(data = dpt2,color=~pal(t_prev),fillOpacity = 0.6, + stroke = TRUE,weight=1, + popup=~paste(as.character(NOM_DEPT),as.character(t_prev),sep=&quot; : &quot;)) %&gt;% + addLayersControl(options=layersControlOptions(collapsed = FALSE)) &gt; m ou avec une autre palette de couleur &gt; pal1 &lt;- colorNumeric(palette = c(&quot;inferno&quot;),domain = dpt2$t_prev) &gt; m1 &lt;- leaflet() %&gt;% addTiles() %&gt;% + addPolygons(data = dpt2,color=~pal1(t_prev),fillOpacity = 0.6, + stroke = TRUE,weight=1, + popup=~paste(as.character(NOM_DEPT),as.character(t_prev),sep=&quot; : &quot;)) %&gt;% + addLayersControl(options=layersControlOptions(collapsed = FALSE)) &gt; m1 "],
["quelques-outils-de-visualisation-interactive-compléments-shiny.html", "Chapitre 3 Quelques outils de visualisation interactive - Compléments shiny 3.1 Représentations classiques avec rAmCharts et plotly 3.2 Graphes pour visualiser des réseaux avec visNetwork 3.3 Dashboard 3.4 Compléments shiny", " Chapitre 3 Quelques outils de visualisation interactive - Compléments shiny Tout comme leaflet pour les cartes, il existe de nombreux outils R dédiés à la visualisation interactive. Nous en présentons quelques uns dans cette partie. 3.1 Représentations classiques avec rAmCharts et plotly Le package rAmCharts est très utile pour donner un carcatère interactif à des représentations graphiques standards (nuages de points, séries temporelles, histogrammes…). Ce package a été fait dans l’esprit d’utiliser les fonctions graphiques de R en utilisant le préfixe am. La syntaxe est très proche de celle des fonctions graphiques standards. On a par exemple : &gt; library(rAmCharts) &gt; amHist(iris$Petal.Length) &gt; amPlot(iris, col = colnames(iris)[1:2], type = c(&quot;l&quot;, &quot;st&quot;), + zoom = TRUE, legend = TRUE) &gt; amBoxplot(iris) plotly permet de faire des choses semblables avec avec une syntaxe spécifique. Les commandes plotly se décomposent essentiellement en 3 parties : le type de représentation graphique (plot_ly}) ; les ajouts que l’on souhaite effectuer (add_trace) ; la gestion de la fenêtre graphique (axes, titres…) (layout). On trouvera un descriptif complet de ces 3 composantes ici. On propose ici de tracer un nuage de points en dimension 2 avec la droite de régression. On commence par générer le nuage et à ajuster le modèle linéaire : &gt; library(plotly) &gt; n &lt;- 100 &gt; X &lt;- runif(n,-5,5) &gt; Y &lt;- 2+3*X+rnorm(n,0,1) &gt; D &lt;- data.frame(X,Y) &gt; model &lt;- lm(Y~X,data=D) On effectue maintenant le tracé &gt; D %&gt;% plot_ly(x=~X,y=~Y) %&gt;% + add_markers(type=&quot;scatter&quot;,mode=&quot;markers&quot;, + marker=list(color=&quot;red&quot;),name=&quot;Nuage&quot;) %&gt;% + add_trace(y=fitted(model),type=&quot;scatter&quot;,mode=&#39;lines&#39;, + name=&quot;Régression&quot;,line=list(color=&quot;blue&quot;)) %&gt;% + layout(title=&quot;Régression&quot;,xaxis=list(title=&quot;abscisse&quot;), + yaxis=list(title=&quot;ordonnées&quot;)) Contrairement à ggplot, plotly permet de faire de la 3D. Par exemple &gt; plot_ly(z = volcano, type = &quot;surface&quot;) &gt; plot_ly(z = volcano, type = &quot;contour&quot;) Il est possible de convertir des graphes ggplot au format plotly avec la fonction ggplotly : &gt; p &lt;- ggplot(iris)+aes(x=Species,y=Sepal.Length)+geom_boxplot()+theme_classic() &gt; ggplotly(p) Exercice 3.1 (Graphes basiques avec rAmCharts et plotly) Pour le jeu de données iris on effectuera les graphes suivants en rAmCharts et plotly. Nuage de points représentant les longueurs et largeurs de Sépales. On utilisera une couleur différente en fonction de l’espèce. &gt; amPlot(Petal.Length~Petal.Width,data=iris,col=iris$Species) &gt; iris %&gt;% plot_ly(x=~Petal.Width,y=~Petal.Length,color=~Species) %&gt;% + add_markers(type=&quot;scatter&quot;,mode=&quot;markers&quot;) Boxplot permettant de visualiser la distribution de la variable Petal.Length en fonction de l’espèce. &gt; amBoxplot(Sepal.Length~Species,data=iris) &gt; iris %&gt;% plot_ly(x=~Species,y=~Sepal.Length) %&gt;% add_boxplot() 3.2 Graphes pour visualiser des réseaux avec visNetwork De nombreuses données peuvent être visualisées à l’aide d’un graphe, notamment lorsqu’il s’agit de représenter des connexions entre individus. Un individu est alors représentés par un noeud et les individus connectés sont reliés par des arrêtes. Le package igraph propose une visualisation statique d’un réseau. Pour donner un caractère dynamique à cetype de représentation, on pourra utiliser le package visNetwork. Une représentation standard visNetwork s’effectue en spécifiant les noeuds et connections d’un graphe, par exemple : &gt; nodes &lt;- data.frame(id = 1:15, label = paste(&quot;Id&quot;, 1:15), + group=sample(LETTERS[1:3], 15, replace = TRUE)) &gt; edges &lt;- data.frame(from = trunc(runif(15)*(15-1))+1,to = trunc(runif(15)*(15-1))+1) &gt; library(visNetwork) &gt; visNetwork(nodes,edges) &gt; visNetwork(nodes, edges) %&gt;% visOptions(highlightNearest = TRUE) &gt; visNetwork(nodes, edges) %&gt;% visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) &gt; visNetwork(nodes, edges) %&gt;% visOptions(selectedBy = &quot;group&quot;) Exercice 3.2 (Interactions entre media) On considère un graphe qui représente des liens entre différents médias. Les données sont présentées ici et on peut les importer avec &gt; nodes &lt;- read.csv(&quot;Dataset1-Media-Example-NODES.csv&quot;, header=T, as.is=T) &gt; links &lt;- read.csv(&quot;Dataset1-Media-Example-EDGES.csv&quot;, header=T, as.is=T) &gt; head(nodes) ## id media media.type type.label audience.size ## 1 s01 NY Times 1 Newspaper 20 ## 2 s02 Washington Post 1 Newspaper 25 ## 3 s03 Wall Street Journal 1 Newspaper 30 ## 4 s04 USA Today 1 Newspaper 32 ## 5 s05 LA Times 1 Newspaper 20 ## 6 s06 New York Post 1 Newspaper 50 &gt; head(links) ## from to weight type ## 1 s01 s02 10 hyperlink ## 2 s01 s02 12 hyperlink ## 3 s01 s03 22 hyperlink ## 4 s01 s04 21 hyperlink ## 5 s04 s11 22 mention ## 6 s05 s15 21 mention L’objet nodes représente les noeuds du graphe et l’objets links les arêtes. On définit l’objet graphe avec &gt; library(igraph) &gt; media &lt;- graph_from_data_frame(d=links, vertices=nodes, directed=T) &gt; V(media)$name &lt;- nodes$media et on peut le visualiser en faisant un plot de cet objet &gt; plot(media) Visualiser ce graphe avec VisNetwork. On pourra utiliser la fonction toVisNetworkData &gt; media.VN &lt;- toVisNetworkData(media) &gt; visNetwork(nodes=media.VN$nodes,edges=media.VN$edges) Ajouter une option qui permette de sélectionner le type de media (Newspaper, TV ou Online). &gt; visNetwork(nodes=media.VN$nodes,edges=media.VN$edges) %&gt;% + visOptions(selectedBy = &quot;type.label&quot;) Utiliser une couleur différente pour chaque type de media. Il suffit de donner le nom group à la variable type.label. &gt; media.VN1 &lt;- media.VN &gt; names(media.VN1$nodes)[3] &lt;- &quot;group&quot; &gt; visNetwork(nodes=media.VN1$nodes,edges=media.VN1$edges) %&gt;% + visOptions(selectedBy = &quot;type.label&quot;) Faire des flèches d’épaisseur différente en fonction du poids (weight). On pourra également ajouter l’option visOptions(highlightNearest = TRUE). Il suffit de donner le nom value à la variable weight. &gt; names(media.VN1$edges)[3] &lt;- &quot;value&quot; &gt; visNetwork(nodes=media.VN1$nodes,edges=media.VN1$edges) %&gt;% + visOptions(selectedBy = &quot;type.label&quot;,highlightNearest = TRUE) 3.3 Dashboard Un tableau de bord permet de visualiser “facilement” et “rapidement” divers graphes et/ou résumés statistiques en lien avec une problématique donnée. Sur R le package flexdashboard permet de construire de tels tableaux de bord. On trouvera un descriptif précis de ce package à cette url : https://rmarkdown.rstudio.com/flexdashboard/. On utilisera cette documentation pour faire l’exercice suivant. Exercice 3.3 (Dashboard pour modèles linéaires) On considère le jeu de données ozone.txt. Le problème est d’expliquer la concentration maximale en ozone quotidienne (variable maxO3) par d’autres variables météorologiques (températures et indicateurs de nébulosité relevés à différents moments de la journée…). On souhaite faire un tableau de bord qui permettra de : visualiser les données : la base de données ainsi qu’un ou deux graphes descriptifs sur la variable à expliquer ; visualiser les modèles linéaires simples : on choisit une variable explicative et on visualise le graphe de la régression ainsi que le modèle ; visualiser le modèle linéaire complet : on affiche le résultat de la régression avec toutes les variables et on représente le graphe des résidus ; choisir les variables explicatives. Avant de réaliser le dashboard, on propose d’écrire quelques commandes pour calculer les différentes sorties : On considère uniquement les variables quantitatives du jeu de données. Visualiser les corrélations entre ces variables à l’aide de la fonction corrplot du package corrplot. &gt; df &lt;- read.table(&quot;ozone.txt&quot;) &gt; cc &lt;- cor(df[,1:11]) &gt; mat.cor &lt;- corrplot::corrplot(cc) Représenter l’histogramme de la variable maxO3, on fera le graphe ggplot et rAmCharts et plotly (en utilisant ggplotly par exemple). &gt; gg.H &lt;- ggplot(df)+aes(x=maxO3)+geom_histogram(bins = 10) &gt; am.H &lt;- amHist(df$maxO3) &gt; pl.H &lt;- ggplotly(gg.H) Construire le modèle linéaire permettant d’expliquer maxO3 par les autres variables. Calculer les résidus studentisés (rstudent) et visualiser ces résidus en fonction de la variable maxO3. Là encore on pourra ajouter un lisseur sur le graphe. &gt; mod &lt;- lm(maxO3~.,data=df) &gt; res &lt;- rstudent(mod) &gt; df1 &lt;- data.frame(maxO3=df$maxO3,r.student=res) &gt; Ggg &lt;- ggplot(df1)+aes(x=maxO3,y=res)+geom_point()+geom_smooth() &gt; Gggp &lt;- ggplotly(Ggg) On peut maintenant passer au tableau de bord. On utilise le menu File -&gt; Rmardown -&gt; From Template -&gt; Flex Dashboard. Construire un premier dashboard permettant de visualiser : le jeu de données sur une colonne (on pourra utiliser la fonction datatable du package DT) l’histogramme de la variable maxO3 ainsi que la matrice des corrélations entre les variables quantitatives. Ajouter un onglet permettant de visualiser les modèles simples à une variable explicative. La variable explicative pourra être choisie à l’aide de Shiny. On pourra par exemple utiliser &gt; radioButtons(&quot;variable1&quot;, + label=&quot;Choisir la variable explicative&quot;, + choices=names(df)[-1], + selected=list(&quot;T9&quot;)) On n’oubliera pas d’ajouter &gt; runtime: shiny dans l’entête. Ajouter un onglet permettant de visualiser les coefficients du modèle linéaire complet ainsi que le graphe des résidus effectués à la questions 1.c. Ajouter un nouvel onglet permettant de choisir les variables explicatives dans le modèle linéaire. Là encore on pourra utiliser des commandes Shiny, par exemple &gt; checkboxGroupInput(&quot;variable&quot;, + label=&quot;Choisir la variable&quot;, + choices=names(df)[-1], + selected=list(&quot;T9&quot;)) Pour les variables choisies, on affichera dans ce nouvel onglet les coefficients du modèle linéaire ainsi que le graphe des résidus studentisés. Le tableau de bord finalisé pourra ressembler à Il est disponible à l’url https://lrouviere.shinyapps.io/dashboard/ 3.4 Compléments shiny Shiny est un package R qui permet la création simple d’applications web intéractives depuis R. On pourra trouver une documentation complète et claire à cet url : https://github.com/datastorm-open/tuto_shiny_rennes. Nous proposons quelques compléments dans les deux exercices suivants. Exercice 3.4 (Une application simple descritptive) On considère le jeu de données SAheart du package bestglm. A l’aide du package rAmCharts, représenter les histogrammes des variables quantitatives du jeu de données ainsi que les boxplots de ces variables en fonction de la variable chd. &gt; library(bestglm) &gt; amHist(SAheart$adiposity,freq=FALSE,xlab=&quot;adiposity&quot;) &gt; amBoxplot(adiposity~chd,data=SAheart) Créer une application shiny qui permette de choisir une variable parmi les variables quantitatives du jeu de données. On pourra utiliser radioButtons avec l’argument &gt; choices=names(SAheart)[sapply(SAheart,class)==&quot;numeric&quot;] visualiser l’histogramme, puis le boxplot en fonction de chd de la variable sélectionnée. Ces graphiques devront être faits avec rAmCharts. On pourra utiliser amChartsOutput. Ldemandée pourra ressembler à Elle est disponible ici https://lrouviere.shinyapps.io/DESC_APP. Exercice 3.5 (Stations velib à Rennes) Réaliser une application qui permette de visualiser les stations velib à Rennes. Elle pourra être du même genre que celle-ci : On peut avoir une meilleure vision ici : https://lrouviere.shinyapps.io/velib/. On récupérera les données sur le site de Rennes métropole : https://data.rennesmetropole.fr/explore/dataset/etat-des-stations-le-velo-star-en-temps-reel/export/ "],
["references.html", "References", " References "]
]
