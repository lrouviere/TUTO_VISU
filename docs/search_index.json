[
["quelques-outils-de-visualisation-interactive-compléments-shiny.html", "Chapitre 3 Quelques outils de visualisation interactive - Compléments shiny 3.1 Représentations classiques avec rAmCharts et plotly 3.2 Graphes pour visualiser des réseaux avec visNetwork 3.3 Dashboard", " Chapitre 3 Quelques outils de visualisation interactive - Compléments shiny Tout comme leaflet pour les cartes, il existe de nombreux outils R dédiés à la visualisation interactive. Nous en présentons quelques uns dans cette partie. 3.1 Représentations classiques avec rAmCharts et plotly Le package rAmCharts est très utile pour donner un carcatère interactif à des représentations graphiques standards (nuages de points, séries temporelles, histogrammes…). Ce package a été fait dans l’esprit d’utiliser les fonctions graphiques de R en utilisant le préfixe am. La syntaxe est très proche de celle des fonctions graphiques standards. On a par exemple : library(rAmCharts) amHist(iris$Petal.Length) amPlot(iris, col = colnames(iris)[1:2], type = c(&quot;l&quot;, &quot;st&quot;), zoom = TRUE, legend = TRUE) amBoxplot(iris) plotly permet de faire des choses semblables avec avec une syntaxe spécifique. Les commandes plotly se décomposent essentiellement en 3 parties : le type de représentation graphique (plot_ly}) ; les ajouts que l’on souhaite effectuer (add_trace) ; la gestion de la fenêtre graphique (axes, titres…) (layout). On trouvera un descriptif complet de ces 3 composantes ici. On propose ici de tracer un nuage de points en dimension 2 avec la droite de régression. On commence par générer le nuage et à ajuster le modèle linéaire : library(plotly) n &lt;- 100 X &lt;- runif(n,-5,5) Y &lt;- 2+3*X+rnorm(n,0,1) D &lt;- data.frame(X,Y) model &lt;- lm(Y~X,data=D) On effectue maintenant le tracé D %&gt;% plot_ly(x=~X,y=~Y) %&gt;% add_markers(type=&quot;scatter&quot;,mode=&quot;markers&quot;, marker=list(color=&quot;red&quot;),name=&quot;Nuage&quot;) %&gt;% add_trace(y=fitted(model),type=&quot;scatter&quot;,mode=&#39;lines&#39;, name=&quot;Régression&quot;,line=list(color=&quot;blue&quot;)) %&gt;% layout(title=&quot;Régression&quot;,xaxis=list(title=&quot;abscisse&quot;), yaxis=list(title=&quot;ordonnées&quot;)) Contrairement à ggplot, plotly permet de faire de la 3D. Par exemple plot_ly(z = volcano, type = &quot;surface&quot;) plot_ly(z = volcano, type = &quot;contour&quot;) Il est possible de convertir des graphes ggplot au format plotly avec la fonction ggplotly : p &lt;- ggplot(iris)+aes(x=Species,y=Sepal.Length)+geom_boxplot()+theme_classic() ggplotly(p) Exercice 3.1 (Graphes basiques avec rAmCharts et plotly) Pour le jeu de données iris on effectuera les graphes suivants en rAmCharts et plotly. Nuage de points représentant les longueurs et largeurs de Sépales. On utilisera une couleur différente en fonction de l’espèce. amPlot(Petal.Length~Petal.Width,data=iris,col=iris$Species) iris %&gt;% plot_ly(x=~Petal.Width,y=~Petal.Length,color=~Species) %&gt;% add_markers(type=&quot;scatter&quot;,mode=&quot;markers&quot;) Boxplot permettant de visualiser la distribution de la variable Petal.Length en fonction de l’espèce. amBoxplot(Sepal.Length~Species,data=iris) iris %&gt;% plot_ly(x=~Species,y=~Sepal.Length) %&gt;% add_boxplot() 3.2 Graphes pour visualiser des réseaux avec visNetwork De nombreuses données peuvent être visualisées à l’aide d’un graphe, notamment lorsqu’il s’agit de représenter des connexions entre individus. Un individu est alors représentés par un noeud et les individus connectés sont reliés par des arrêtes. Le package igraph propose une visualisation statique d’un réseau. Pour donner un caractère dynamique à cetype de représentation, on pourra utiliser le package visNetwork. Une représentation standard visNetwork s’effectue en spécifiant les noeuds et connections d’un graphe, par exemple : nodes &lt;- data.frame(id = 1:15, label = paste(&quot;Id&quot;, 1:15),group=sample(LETTERS[1:3], 15, replace = TRUE)) edges &lt;- data.frame(from = trunc(runif(15)*(15-1))+1,to = trunc(runif(15)*(15-1))+1) library(visNetwork) visNetwork(nodes,edges) visNetwork(nodes, edges) %&gt;% visOptions(highlightNearest = TRUE) visNetwork(nodes, edges) %&gt;% visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) visNetwork(nodes, edges) %&gt;% visOptions(selectedBy = &quot;group&quot;) Exercice 3.2 (Interactions entre media) On considère un graphe qui représente des liens entre différents médias. Les données sont présentées ici et on peut les importer avec nodes &lt;- read.csv(&quot;Dataset1-Media-Example-NODES.csv&quot;, header=T, as.is=T) links &lt;- read.csv(&quot;Dataset1-Media-Example-EDGES.csv&quot;, header=T, as.is=T) head(nodes) ## id media media.type type.label audience.size ## 1 s01 NY Times 1 Newspaper 20 ## 2 s02 Washington Post 1 Newspaper 25 ## 3 s03 Wall Street Journal 1 Newspaper 30 ## 4 s04 USA Today 1 Newspaper 32 ## 5 s05 LA Times 1 Newspaper 20 ## 6 s06 New York Post 1 Newspaper 50 head(links) ## from to weight type ## 1 s01 s02 10 hyperlink ## 2 s01 s02 12 hyperlink ## 3 s01 s03 22 hyperlink ## 4 s01 s04 21 hyperlink ## 5 s04 s11 22 mention ## 6 s05 s15 21 mention L’objet nodes représente les noeuds du graphe et l’objets links les arêtes. On définit l’objet graphe avec library(igraph) media &lt;- graph_from_data_frame(d=links, vertices=nodes, directed=T) V(media)$name &lt;- nodes$media et on peut le visualiser en faisant un plot de cet objet plot(media) Visualiser ce graphe avec VisNetwork. On pourra utiliser la fonction toVisNetworkData media.VN &lt;- toVisNetworkData(media) visNetwork(nodes=media.VN$nodes,edges=media.VN$edges) Ajouter une option qui permette de sélectionner le type de media (Newspaper, TV ou Online). visNetwork(nodes=media.VN$nodes,edges=media.VN$edges) %&gt;% visOptions(selectedBy = &quot;type.label&quot;) Utiliser une couleur différente pour chaque type de media. Il suffit de donner le nom group à la variable type.label. media.VN1 &lt;- media.VN names(media.VN1$nodes)[3] &lt;- &quot;group&quot; visNetwork(nodes=media.VN1$nodes,edges=media.VN1$edges) %&gt;% visOptions(selectedBy = &quot;type.label&quot;) Faire des flèches d’épaisseur différente en fonction du poids (weight). On pourra également ajouter l’option visOptions(highlightNearest = TRUE). Il suffit de donner le nom value à la variable weight. names(media.VN1$edges)[3] &lt;- &quot;value&quot; visNetwork(nodes=media.VN1$nodes,edges=media.VN1$edges) %&gt;% visOptions(selectedBy = &quot;type.label&quot;,highlightNearest = TRUE) 3.3 Dashboard Un tableau de bord permet de visualiser “facilement” et “rapidement” divers graphes et/ou résumés statistiques en lien avec une problématique donnée. Sur R le package flexdashboard permet de construire de tels tableaux de bord. On trouvera un descriptif précis de ce package à cette url : https://rmarkdown.rstudio.com/flexdashboard/. On utilisera cette documentation pour faire l’exercice suivant. Exercice 3.3 (Dashboard pour modèles linéaires) On considère le jeu de données ozone.txt. Le problème est d’expliquer la concentration maximale en ozone quotidienne (variable maxO3) par d’autres variables météorologiques (températures et indicateurs de nébulosité relevés à différents moments de la journée…). On souhaite faire un tableau de bord qui permettra de : visualiser les données : la base de données ainsi qu’un ou deux graphes descriptifs sur la variable à expliquer ; visualiser les modèles linéaires simples : on choisit une variable explicative et on visualise le graphe de la régression ainsi que le modèle ; visualiser le modèle linéaire complet : on affiche le résultat de la régression avec toutes les variables et on représente le graphe des résidus ; choisir les variables explicatives. Avant de réaliser le dashboard, on propose d’écrire quelques commandes pour calculer les différentes sorties : On considère uniquement les variables quantitatives du jeu de données. Visualiser les corrélations entre ces variables à l’aide de la fonction corrplot du package corrplot. df &lt;- read.table(&quot;ozone.txt&quot;) cc &lt;- cor(df[,1:11]) mat.cor &lt;- corrplot::corrplot(cc) Représenter l’histogramme de la variable maxO3, on fera le graphe ggplot et rAmCharts et plotly (en utilisant ggplotly par exemple). gg.H &lt;- ggplot(df)+aes(x=maxO3)+geom_histogram(bins = 10) am.H &lt;- amHist(df$maxO3) pl.H &lt;- ggplotly(gg.H) Construire le modèle linéaire permettant d’expliquer maxO3 par les autres variables. Calculer les résidus studentisés (rstudent) et visualiser ces résidus en fonction de la variable maxO3. Là encore on pourra ajouter un lisseur sur le graphe. mod &lt;- lm(maxO3~.,data=df) res &lt;- rstudent(mod) df1 &lt;- data.frame(maxO3=df$maxO3,r.student=res) Ggg &lt;- ggplot(df1)+aes(x=maxO3,y=res)+geom_point()+geom_smooth() Gggp &lt;- ggplotly(Ggg) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; On peut maintenant passer au tableau de bord. On utilise le menu File -&gt; Rmardown -&gt; From Template -&gt; Flex Dashboard. Construire un premier dashboard permettant de visualiser : le jeu de données sur une colonne (on pourra utiliser la fonction datatable du package DT) l’histogramme de la variable maxO3 ainsi que la matrice des corrélations entre les variables quantitatives. Ajouter un onglet permettant de visualiser les modèles simples à une variable explicative. La variable explicative pourra être choisie à l’aide de Shiny. On pourra par exemple utiliser radioButtons(&quot;variable1&quot;, label=&quot;Choisir la variable explicative&quot;, choices=names(df)[-1], selected=list(&quot;T9&quot;)) On n’oubliera pas d’ajouter runtime: shiny dans l’entête. Ajouter un onglet permettant de visualiser les coefficients du modèle linéaire complet ainsi que le graphe des résidus effectués à la questions 1.c. Ajouter un nouvel onglet permettant de choisir les variables explicatives dans le modèle linéaire. Là encore on pourra utiliser des commandes Shiny, par exemple checkboxGroupInput(&quot;variable&quot;, label=&quot;Choisir la variable&quot;, choices=names(df)[-1], selected=list(&quot;T9&quot;)) Pour les variables choisies, on affichera dans ce nouvel onglet les coefficients du modèle linéaire ainsi que le graphe des résidus studentisés. Le tableau de bord finalisé pourra ressembler à knitr::include_app(&#39;https://lrouviere.shinyapps.io/dashboard/&#39;, height = &#39;600px&#39;) Il est disponible à l’url https://lrouviere.shinyapps.io/dashboard/ "]
]
